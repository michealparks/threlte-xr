import{s as Q,B as H,C as N,D as fe,a as z,c as S,i as C,y as I,d as x,p as ie,G as le,z as J,b as $e,o as me,r as ue,u as ce,v as pe,w as _e,L as A,M as ge}from"../chunks/scheduler.2c057a9d.js";import{S as V,i as L,b as p,d as _,m as g,a as u,t as c,e as d,f as de}from"../chunks/index.9b7b00d5.js";import{u as Y,Q as ve,T as M,g as ye,a as we,bN as be,bO as W,bP as q,b7 as he,j as Me,V as B,M as ze,bQ as Se,b as K,bR as Ce,bS as xe,X as Pe,c as Re,H as ke,f as De}from"../chunks/xr.6f8fc35a.js";import{B as Te}from"../chunks/button-vr.ade700e4.js";import{e as Oe}from"../chunks/each.ed328caf.js";const Ge=new ve,G={x:0,y:0,z:0},Z=()=>{const{xr:o}=Y().renderer;let t=o.getReferenceSpace();return(n,r=Ge)=>{if(t??(t=o.getReferenceSpace()),t===null)return;let s=0,e=0,f=0;Array.isArray(n)?[s,e,f]=n:(s=n.x,e=n.y,f=n.z),G.x=-s,G.y=-e,G.z=-f;const m=o.getFrame().getViewerPose(t);m!==void 0&&(G.x+=m.transform.position.x,G.z+=m.transform.position.z);const v=new XRRigidTransform(G,r);o.setReferenceSpace(t.getOffsetReferenceSpace(v))}};function Fe(o){let t,n,r,s;return t=new M.PlaneGeometry({props:{args:[.5,.5]}}),t.$on("create",o[3]),r=new M.ShaderMaterial({props:{fragmentShader:o[0],vertexShader:o[1],transparent:!0,polygonOffset:!0,polygonOffsetFactor:-1}}),r.$on("create",Xe),{c(){p(t.$$.fragment),n=z(),p(r.$$.fragment)},l(e){_(t.$$.fragment,e),n=S(e),_(r.$$.fragment,e)},m(e,f){g(t,e,f),C(e,n,f),g(r,e,f),s=!0},p:I,i(e){s||(u(t.$$.fragment,e),u(r.$$.fragment,e),s=!0)},o(e){c(t.$$.fragment,e),c(r.$$.fragment,e),s=!1},d(e){e&&x(n),d(t,e),d(r,e)}}}function Ue(o){let t,n;const r=[{name:"Teleport Marker"},{renderOrder:9999},o[2]];let s={$$slots:{default:[Fe]},$$scope:{ctx:o}};for(let e=0;e<r.length;e+=1)s=H(s,r[e]);return t=new M.Mesh({props:s}),{c(){p(t.$$.fragment)},l(e){_(t.$$.fragment,e)},m(e,f){g(t,e,f),n=!0},p(e,[f]){const m=f&4?ye(r,[r[0],r[1],we(e[2])]):{};f&16&&(m.$$scope={dirty:f,ctx:e}),t.$set(m)},i(e){n||(u(t.$$.fragment,e),n=!0)},o(e){c(t.$$.fragment,e),n=!1},d(e){d(t,e)}}}const Xe=({ref:o})=>o.uniforms.size={value:10};function je(o,t,n){const r=[];let s=N(t,r);const e=`
uniform float time;
uniform float size;
varying vec2 vUv;
void main(){
  float sinx = sin(time) / 8. + 0.3;
  float strength = 1.0 - step(0.01, abs(distance(vUv, vec2(0.5)) - sinx));

  // float strength = 1.0 - step(0.01, abs(distance(vUv, vec2(0.5)) - size));
  gl_FragColor = vec4(strength);
}`,f=`
varying vec2 vUv;
void main(){
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`,m=({ref:v})=>v.rotateX(-Math.PI/2);return o.$$set=v=>{t=H(H({},t),fe(v)),n(2,s=N(t,r))},[e,f,s,m]}class Ae extends V{constructor(t){super(),L(this,t,je,Ue,Q,{})}}function Be(o){let t;const n=o[7].default,r=ue(n,o,o[9],null);return{c(){r&&r.c()},l(s){r&&r.l(s)},m(s,e){r&&r.m(s,e),t=!0},p(s,e){r&&r.p&&(!t||e&512)&&ce(r,n,s,s[9],t?_e(n,s[9],e,null):pe(s[9]),null)},i(s){t||(u(r,s),t=!0)},o(s){c(r,s),t=!1},d(s){r&&r.d(s)}}}function Qe(o){var R,y,i;let t,n,r,s,e,f,m;function v(a){o[8](a)}let w={$$slots:{default:[Be]},$$scope:{ctx:o}};return o[0]!==void 0&&(w.ref=o[0]),t=new M.Group({props:w}),ie.push(()=>de(t,"ref",v)),s=new be({props:{visible:o[2]!==void 0&&o[1]!==void 0,positions:o[3]}}),f=new Ae({props:{visible:o[2]!==void 0&&o[1]!==void 0,"position.x":(R=o[1])==null?void 0:R.x,"position.y":(y=o[1])==null?void 0:y.y,"position.z":(i=o[1])==null?void 0:i.z}}),{c(){p(t.$$.fragment),r=z(),p(s.$$.fragment),e=z(),p(f.$$.fragment)},l(a){_(t.$$.fragment,a),r=S(a),_(s.$$.fragment,a),e=S(a),_(f.$$.fragment,a)},m(a,$){g(t,a,$),C(a,r,$),g(s,a,$),C(a,e,$),g(f,a,$),m=!0},p(a,[$]){var O,F,k;const b={};$&512&&(b.$$scope={dirty:$,ctx:a}),!n&&$&1&&(n=!0,b.ref=a[0],le(()=>n=!1)),t.$set(b);const h={};$&6&&(h.visible=a[2]!==void 0&&a[1]!==void 0),$&8&&(h.positions=a[3]),s.$set(h);const D={};$&6&&(D.visible=a[2]!==void 0&&a[1]!==void 0),$&2&&(D["position.x"]=(O=a[1])==null?void 0:O.x),$&2&&(D["position.y"]=(F=a[1])==null?void 0:F.y),$&2&&(D["position.z"]=(k=a[1])==null?void 0:k.z),f.$set(D)},i(a){m||(u(t.$$.fragment,a),u(s.$$.fragment,a),u(f.$$.fragment,a),m=!0)},o(a){c(t.$$.fragment,a),c(s.$$.fragment,a),c(f.$$.fragment,a),m=!1},d(a){a&&(x(r),x(e)),d(t,a),d(s,a),d(f,a)}}}const E=40;function Ve(o,t,n){let r,s,e,f;J(o,W,l=>n(14,e=l)),J(o,q,l=>n(15,f=l));let{$$slots:m={},$$scope:v}=t,{raycaster:w=new he}=t,{handedness:R="right"}=t,{maxDistance:y=20}=t;const i=Me();let a,$=[],b,h;const D=Z(),O=new B,F=new ze,k=new B,T=new Float32Array(E*3),U=new Se,X=new B,ee=(l,P)=>{k.x=(l.x+P.x)/2,k.y=(l.y+P.y)/2,k.z=(l.z+P.z)/2},{start:te,stop:re}=K(()=>{if(h===void 0)return;F.identity().extractRotation(h.matrixWorld),w.ray.origin.setFromMatrixPosition(h.matrixWorld),w.ray.direction.set(0,0,-1).applyMatrix4(F);const[l]=w.intersectObjects($);if(l===void 0){n(1,b=void 0),A(q,f=void 0,f);return}n(1,b=l.point),A(q,f=b,f),h.getWorldPosition(O),ee(O,b),k.y+=.8,U.v0.copy(O),U.v1.copy(k),U.v2.copy(l.point);for(let P=0,j=0;P<E;P+=1,j+=3){const oe=P/E;U.getPoint(oe,X),n(3,T[j+0]=X.x,T),n(3,T[j+1]=X.y,T),n(3,T[j+2]=X.z,T)}},{autostart:!1}),ne=l=>{n(2,h=l),A(W,e=l,e),te()},se=()=>{re(),n(2,h=void 0),A(W,e=void 0,e),b!==void 0&&(D(b),i("teleport",b))};K(()=>{var P;const l=(((P=s.current)==null?void 0:P.axes[3])??0)<-.9;l&&h===void 0?ne(r.current.controller):!l&&h!==void 0&&se()}),$e(()=>{$=a.children}),me(()=>{$=a.children});function ae(l){a=l,n(0,a)}return o.$$set=l=>{"raycaster"in l&&n(4,w=l.raycaster),"handedness"in l&&n(5,R=l.handedness),"maxDistance"in l&&n(6,y=l.maxDistance),"$$scope"in l&&n(9,v=l.$$scope)},o.$$.update=()=>{o.$$.dirty&64&&n(4,w.far=y,w),o.$$.dirty&32&&(r=Ce(R)),o.$$.dirty&32&&(s=xe(R))},[a,b,h,T,w,R,y,m,ae,v]}class Le extends V{constructor(t){super(),L(this,t,Ve,Qe,Q,{raycaster:4,handedness:5,maxDistance:6})}}function We(o,t,n){const r=o.slice();return r[3]=t[n],r}function qe(o){let t,n,r,s;return t=new Re({}),r=new ke({}),{c(){p(t.$$.fragment),n=z(),p(r.$$.fragment)},l(e){_(t.$$.fragment,e),n=S(e),_(r.$$.fragment,e)},m(e,f){g(t,e,f),C(e,n,f),g(r,e,f),s=!0},i(e){s||(u(t.$$.fragment,e),u(r.$$.fragment,e),s=!0)},o(e){c(t.$$.fragment,e),c(r.$$.fragment,e),s=!1},d(e){e&&x(n),d(t,e),d(r,e)}}}function Ee(o){let t,n,r,s;return t=new M.CircleGeometry({props:{args:[20]}}),r=new M.MeshStandardMaterial({props:{color:"#444"}}),{c(){p(t.$$.fragment),n=z(),p(r.$$.fragment)},l(e){_(t.$$.fragment,e),n=S(e),_(r.$$.fragment,e)},m(e,f){g(t,e,f),C(e,n,f),g(r,e,f),s=!0},p:I,i(e){s||(u(t.$$.fragment,e),u(r.$$.fragment,e),s=!0)},o(e){c(t.$$.fragment,e),c(r.$$.fragment,e),s=!1},d(e){e&&x(n),d(t,e),d(r,e)}}}function He(o){let t,n;return t=new M.Mesh({props:{rotation:[-Math.PI/2,0,0],$$slots:{default:[Ee]},$$scope:{ctx:o}}}),{c(){p(t.$$.fragment)},l(r){_(t.$$.fragment,r)},m(r,s){g(t,r,s),n=!0},p(r,s){const e={};s&64&&(e.$$scope={dirty:s,ctx:r}),t.$set(e)},i(r){n||(u(t.$$.fragment,r),n=!0)},o(r){c(t.$$.fragment,r),n=!1},d(r){d(t,r)}}}function Ie(o){let t,n,r,s;return t=new M.CylinderGeometry({props:{args:[1,1,.1]}}),r=new M.MeshStandardMaterial({props:{color:"#fff"}}),{c(){p(t.$$.fragment),n=z(),p(r.$$.fragment)},l(e){_(t.$$.fragment,e),n=S(e),_(r.$$.fragment,e)},m(e,f){g(t,e,f),C(e,n,f),g(r,e,f),s=!0},p:I,i(e){s||(u(t.$$.fragment,e),u(r.$$.fragment,e),s=!0)},o(e){c(t.$$.fragment,e),c(r.$$.fragment,e),s=!1},d(e){e&&x(n),d(t,e),d(r,e)}}}function Ne(o){let t,n;return t=new M.Mesh({props:{position:o[3],renderOrder:10,$$slots:{default:[Ie]},$$scope:{ctx:o}}}),{c(){p(t.$$.fragment)},l(r){_(t.$$.fragment,r)},m(r,s){g(t,r,s),n=!0},p(r,s){const e={};s&64&&(e.$$scope={dirty:s,ctx:r}),t.$set(e)},i(r){n||(u(t.$$.fragment,r),n=!0)},o(r){c(t.$$.fragment,r),n=!1},d(r){d(t,r)}}}function Je(o){let t,n,r,s,e,f,m,v,w;t=new Pe({props:{$$slots:{default:[qe]},$$scope:{ctx:o}}}),r=new Le({props:{handedness:"left",$$slots:{default:[He]},$$scope:{ctx:o}}});let R=Oe([[0,0,8],[8,0,0],[0,0,-8],[-8,0,3]]),y=[];for(let i=0;i<4;i+=1)y[i]=Ne(We(o,R,i));return f=new M.AmbientLight({}),v=new M.DirectionalLight({}),{c(){p(t.$$.fragment),n=z(),p(r.$$.fragment),s=z();for(let i=0;i<4;i+=1)y[i].c();e=z(),p(f.$$.fragment),m=z(),p(v.$$.fragment)},l(i){_(t.$$.fragment,i),n=S(i),_(r.$$.fragment,i),s=S(i);for(let a=0;a<4;a+=1)y[a].l(i);e=S(i),_(f.$$.fragment,i),m=S(i),_(v.$$.fragment,i)},m(i,a){g(t,i,a),C(i,n,a),g(r,i,a),C(i,s,a);for(let $=0;$<4;$+=1)y[$]&&y[$].m(i,a);C(i,e,a),g(f,i,a),C(i,m,a),g(v,i,a),w=!0},p(i,[a]){const $={};a&64&&($.$$scope={dirty:a,ctx:i}),t.$set($);const b={};a&64&&(b.$$scope={dirty:a,ctx:i}),r.$set(b)},i(i){if(!w){u(t.$$.fragment,i),u(r.$$.fragment,i);for(let a=0;a<4;a+=1)u(y[a]);u(f.$$.fragment,i),u(v.$$.fragment,i),w=!0}},o(i){c(t.$$.fragment,i),c(r.$$.fragment,i),y=y.filter(Boolean);for(let a=0;a<4;a+=1)c(y[a]);c(f.$$.fragment,i),c(v.$$.fragment,i),w=!1},d(i){i&&(x(n),x(s),x(e),x(m)),d(t,i),d(r,i),ge(y,i),d(f,i),d(v,i)}}}function Ke(o){const{camera:t,renderer:n}=Y(),r=Z();return n.setClearColor(0),t.current.position.z=1.75,t.current.lookAt(0,1.75,1),r(new B(.5,0,.5)),[]}class Ye extends V{constructor(t){super(),L(this,t,Ke,Je,Q,{})}}function Ze(o){let t,n;return t=new Ye({}),{c(){p(t.$$.fragment)},l(r){_(t.$$.fragment,r)},m(r,s){g(t,r,s),n=!0},i(r){n||(u(t.$$.fragment,r),n=!0)},o(r){c(t.$$.fragment,r),n=!1},d(r){d(t,r)}}}function et(o){let t,n,r,s;return t=new De({props:{$$slots:{default:[Ze]},$$scope:{ctx:o}}}),r=new Te({}),{c(){p(t.$$.fragment),n=z(),p(r.$$.fragment)},l(e){_(t.$$.fragment,e),n=S(e),_(r.$$.fragment,e)},m(e,f){g(t,e,f),C(e,n,f),g(r,e,f),s=!0},p(e,[f]){const m={};f&1&&(m.$$scope={dirty:f,ctx:e}),t.$set(m)},i(e){s||(u(t.$$.fragment,e),u(r.$$.fragment,e),s=!0)},o(e){c(t.$$.fragment,e),c(r.$$.fragment,e),s=!1},d(e){e&&x(n),d(t,e),d(r,e)}}}class ot extends V{constructor(t){super(),L(this,t,null,et,Q,{})}}export{ot as component};
